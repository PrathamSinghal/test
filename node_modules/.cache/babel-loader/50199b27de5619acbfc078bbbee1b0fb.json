{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst MergeSort = () => {\n  _s();\n\n  const myState = useSelector(state => state.updateProps);\n  const dispatch = useDispatch();\n  let values = myState.values.map(item => item[0]);\n  let ids = myState.values.map(item => item[1]);\n\n  const mergeSort = (values, ids, timer, l, r) => {\n    if (l >= r) return;\n    let mid = Math.floor((l + r) / 2);\n    mergeSort(values, ids, timer - 1, l, mid);\n    mergeSort(values, ids, timer - 1, mid + 1, r);\n    setTimeout(() => {\n      let color = [];\n\n      for (let i = 0; i < 3; i++) color.push(Math.floor(Math.random() * 200));\n\n      for (let i = l; i <= r; i++) document.getElementById(ids[i]).childNodes[1].style.backgroundColor = `rgb(${color[0]},${color[1]},${color[2]})`;\n\n      for (let i = l; i <= r; i++) {\n        for (let j = i + 1; j <= r; j++) {\n          if (values[i] > values[j]) {\n            [values[i], values[j]] = [values[j], values[i]];\n            [ids[i], ids[j]] = [ids[j], ids[i]];\n            let new_ids = [...ids];\n            document.getElementById(new_ids[i]).style.transform = `translateX(${i * 11}px)`;\n            document.getElementById(new_ids[j]).style.transform = `translateX(${j * 11}px)`;\n          }\n        }\n      }\n    }, timer * myState.speed * 5);\n  };\n\n  const solve = () => {\n    mergeSort(values, ids, Math.ceil(Math.log(values.length + 1)), 0, values.length - 1);\n    setTimeout(() => {\n      dispatch({\n        type: 'PLAY_PAUSE',\n        _play: false\n      });\n      dispatch({\n        type: 'UPDATE_COLOR',\n        color: 'rgb(0, 182, 0)'\n      });\n    }, 5 * myState.speed * (1 + Math.ceil(Math.log(values.length + 1))) + 50);\n  };\n\n  useEffect(() => {\n    if (myState.algorithm === 'merge') {\n      if (myState.play) solve();\n    }\n  }, [myState.algorithm, myState.play]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n\n_s(MergeSort, \"skz74H6TDd0rxZTKTPFjX8UUY3g=\", false, function () {\n  return [useSelector, useDispatch];\n});\n\n_c = MergeSort;\nexport default MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"sources":["C:/Users/SAKSHI SINGH/OneDrive/Desktop/algovisualizer-main-main/src/components/MergeSort.js"],"names":["React","useEffect","useDispatch","useSelector","MergeSort","myState","state","updateProps","dispatch","values","map","item","ids","mergeSort","timer","l","r","mid","Math","floor","setTimeout","color","i","push","random","document","getElementById","childNodes","style","backgroundColor","j","new_ids","transform","speed","solve","ceil","log","length","type","_play","algorithm","play"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,aAAzC;;;;AAEA,MAAMC,SAAS,GAAG,MAAM;AAAA;;AACrB,QAAMC,OAAO,GAAGF,WAAW,CAACG,KAAK,IAAIA,KAAK,CAACC,WAAhB,CAA3B;AACA,QAAMC,QAAQ,GAAGN,WAAW,EAA5B;AAEA,MAAIO,MAAM,GAAGJ,OAAO,CAACI,MAAR,CAAeC,GAAf,CAAoBC,IAAD,IAAUA,IAAI,CAAC,CAAD,CAAjC,CAAb;AACA,MAAIC,GAAG,GAAGP,OAAO,CAACI,MAAR,CAAeC,GAAf,CAAoBC,IAAD,IAAUA,IAAI,CAAC,CAAD,CAAjC,CAAV;;AAEA,QAAME,SAAS,GAAG,CAACJ,MAAD,EAASG,GAAT,EAAcE,KAAd,EAAqBC,CAArB,EAAwBC,CAAxB,KAA8B;AAC7C,QAAID,CAAC,IAAIC,CAAT,EACG;AAEH,QAAIC,GAAG,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACJ,CAAC,GAAGC,CAAL,IAAU,CAArB,CAAV;AAEAH,IAAAA,SAAS,CAACJ,MAAD,EAASG,GAAT,EAAcE,KAAK,GAAG,CAAtB,EAAyBC,CAAzB,EAA4BE,GAA5B,CAAT;AACAJ,IAAAA,SAAS,CAACJ,MAAD,EAASG,GAAT,EAAcE,KAAK,GAAG,CAAtB,EAAyBG,GAAG,GAAG,CAA/B,EAAkCD,CAAlC,CAAT;AAEAI,IAAAA,UAAU,CAAC,MAAM;AACd,UAAIC,KAAK,GAAG,EAAZ;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EACGD,KAAK,CAACE,IAAN,CAAWL,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACM,MAAL,KAAgB,GAA3B,CAAX;;AAEH,WAAK,IAAIF,CAAC,GAAGP,CAAb,EAAgBO,CAAC,IAAIN,CAArB,EAAwBM,CAAC,EAAzB,EACGG,QAAQ,CAACC,cAAT,CAAwBd,GAAG,CAACU,CAAD,CAA3B,EAAgCK,UAAhC,CAA2C,CAA3C,EAA8CC,KAA9C,CAAoDC,eAApD,GAAuE,OAAMR,KAAK,CAAC,CAAD,CAAI,IAAGA,KAAK,CAAC,CAAD,CAAI,IAAGA,KAAK,CAAC,CAAD,CAAI,GAA9G;;AAEH,WAAK,IAAIC,CAAC,GAAGP,CAAb,EAAgBO,CAAC,IAAIN,CAArB,EAAwBM,CAAC,EAAzB,EAA6B;AAC1B,aAAK,IAAIQ,CAAC,GAAGR,CAAC,GAAG,CAAjB,EAAoBQ,CAAC,IAAId,CAAzB,EAA4Bc,CAAC,EAA7B,EAAiC;AAE9B,cAAIrB,MAAM,CAACa,CAAD,CAAN,GAAYb,MAAM,CAACqB,CAAD,CAAtB,EAA2B;AACxB,aAACrB,MAAM,CAACa,CAAD,CAAP,EAAYb,MAAM,CAACqB,CAAD,CAAlB,IAAyB,CAACrB,MAAM,CAACqB,CAAD,CAAP,EAAYrB,MAAM,CAACa,CAAD,CAAlB,CAAzB;AACA,aAACV,GAAG,CAACU,CAAD,CAAJ,EAASV,GAAG,CAACkB,CAAD,CAAZ,IAAmB,CAAClB,GAAG,CAACkB,CAAD,CAAJ,EAASlB,GAAG,CAACU,CAAD,CAAZ,CAAnB;AAEA,gBAAIS,OAAO,GAAG,CAAC,GAAGnB,GAAJ,CAAd;AAEAa,YAAAA,QAAQ,CAACC,cAAT,CAAwBK,OAAO,CAACT,CAAD,CAA/B,EAAoCM,KAApC,CAA0CI,SAA1C,GAAuD,cAAaV,CAAC,GAAG,EAAG,KAA3E;AACAG,YAAAA,QAAQ,CAACC,cAAT,CAAwBK,OAAO,CAACD,CAAD,CAA/B,EAAoCF,KAApC,CAA0CI,SAA1C,GAAuD,cAAaF,CAAC,GAAG,EAAG,KAA3E;AACF;AACH;AACH;AACH,KAtBS,EAsBPhB,KAAK,GAAGT,OAAO,CAAC4B,KAAhB,GAAwB,CAtBjB,CAAV;AAuBF,GAhCD;;AAkCA,QAAMC,KAAK,GAAG,MAAM;AACjBrB,IAAAA,SAAS,CAACJ,MAAD,EAASG,GAAT,EAAcM,IAAI,CAACiB,IAAL,CAAUjB,IAAI,CAACkB,GAAL,CAAS3B,MAAM,CAAC4B,MAAP,GAAgB,CAAzB,CAAV,CAAd,EAAsD,CAAtD,EAAyD5B,MAAM,CAAC4B,MAAP,GAAgB,CAAzE,CAAT;AAEAjB,IAAAA,UAAU,CAAC,MAAM;AACdZ,MAAAA,QAAQ,CAAC;AACN8B,QAAAA,IAAI,EAAE,YADA;AAENC,QAAAA,KAAK,EAAE;AAFD,OAAD,CAAR;AAKA/B,MAAAA,QAAQ,CAAC;AACN8B,QAAAA,IAAI,EAAE,cADA;AAENjB,QAAAA,KAAK,EAAE;AAFD,OAAD,CAAR;AAIF,KAVS,EAUP,IAAIhB,OAAO,CAAC4B,KAAZ,IAAqB,IAAIf,IAAI,CAACiB,IAAL,CAAUjB,IAAI,CAACkB,GAAL,CAAS3B,MAAM,CAAC4B,MAAP,GAAgB,CAAzB,CAAV,CAAzB,IAAmE,EAV5D,CAAV;AAWF,GAdD;;AAgBApC,EAAAA,SAAS,CAAC,MAAM;AACb,QAAII,OAAO,CAACmC,SAAR,KAAsB,OAA1B,EAAmC;AAChC,UAAInC,OAAO,CAACoC,IAAZ,EACGP,KAAK;AACV;AACH,GALQ,EAKN,CAAC7B,OAAO,CAACmC,SAAT,EAAoBnC,OAAO,CAACoC,IAA5B,CALM,CAAT;AAOA,sBAAO,qCAAP;AACF,CAjED;;GAAMrC,S;UACaD,W,EACCD,W;;;KAFdE,S;AAmEN,eAAeA,SAAf","sourcesContent":["import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nconst MergeSort = () => {\n   const myState = useSelector(state => state.updateProps);\n   const dispatch = useDispatch();\n\n   let values = myState.values.map((item) => item[0]);\n   let ids = myState.values.map((item) => item[1]);\n\n   const mergeSort = (values, ids, timer, l, r) => {\n      if (l >= r)\n         return;\n\n      let mid = Math.floor((l + r) / 2);\n\n      mergeSort(values, ids, timer - 1, l, mid);\n      mergeSort(values, ids, timer - 1, mid + 1, r);\n\n      setTimeout(() => {\n         let color = [];\n         for (let i = 0; i < 3; i++)\n            color.push(Math.floor(Math.random() * 200));\n\n         for (let i = l; i <= r; i++)\n            document.getElementById(ids[i]).childNodes[1].style.backgroundColor = `rgb(${color[0]},${color[1]},${color[2]})`;\n\n         for (let i = l; i <= r; i++) {\n            for (let j = i + 1; j <= r; j++) {\n\n               if (values[i] > values[j]) {\n                  [values[i], values[j]] = [values[j], values[i]];\n                  [ids[i], ids[j]] = [ids[j], ids[i]];\n\n                  let new_ids = [...ids];\n\n                  document.getElementById(new_ids[i]).style.transform = `translateX(${i * 11}px)`;\n                  document.getElementById(new_ids[j]).style.transform = `translateX(${j * 11}px)`;\n               }\n            }\n         }\n      }, timer * myState.speed * 5);\n   }\n\n   const solve = () => {\n      mergeSort(values, ids, Math.ceil(Math.log(values.length + 1)), 0, values.length - 1);\n\n      setTimeout(() => {\n         dispatch({\n            type: 'PLAY_PAUSE',\n            _play: false\n         })\n\n         dispatch({\n            type: 'UPDATE_COLOR',\n            color: 'rgb(0, 182, 0)'\n         })\n      }, 5 * myState.speed * (1 + Math.ceil(Math.log(values.length + 1))) + 50);\n   };\n\n   useEffect(() => {\n      if (myState.algorithm === 'merge') {\n         if (myState.play)\n            solve();\n      }\n   }, [myState.algorithm, myState.play]);\n\n   return <></>;\n}\n\nexport default MergeSort;\n"]},"metadata":{},"sourceType":"module"}